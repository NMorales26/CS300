What was the problem you were solving in the projects for this course?

In these projects, the primary problem was to implement and analyze different data structures (Vector, Hash Table, and Binary Search Tree) and to sort and print out a list of courses in the Computer Science program in alphanumeric order. The goal was to understand how these data structures work, their efficiency, and their practical applications.

How did you approach the problem? Consider why data structures are important to understand.

The approach involved writing pseudocode for the Vector, Hash Table, and Binary Search Tree, followed by analyzing their runtime and memory usage. For the sorting and printing task, the focus was on developing a robust sorting algorithm to handle the courses efficiently. Understanding data structures is crucial as they form the backbone of efficient algorithm design, influencing the performance and scalability of software solutions.

How did you overcome any roadblocks you encountered while going through the activities or project?

I encountered several challenges, such as optimizing the hash function to minimize collisions and ensuring the Binary Search Tree remains balanced to prevent performance degradation. These were overcome by researching best practices, experimenting with different implementations, and testing extensively to ensure reliability.

How has your work on this project expanded your approach to designing software and developing programs?

Working on these projects has deepened my understanding of choosing appropriate data structures based on the problem requirements. It has taught me the importance of considering both average and worst-case scenarios when designing algorithms, leading to more robust and efficient software design.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

This project has reinforced the value of writing clean, modular code that is easy to read and maintain. By adhering to best practices, such as meaningful variable names, comments, and breaking down complex functions into smaller, manageable pieces, I have improved my ability to write adaptable and maintainable code.
